{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE TupleSections #-}
{-# OPTIONS_GHC -Wno-incomplete-patterns #-}
module Problem8 where

import Control.Applicative (liftA2)

{-------------------------------------------------------------------------------

CS:3820 Fall 2021 Problem of the Week, Week 8
=============================================

This problem concerns defining monads.  Our goal is to define a monad and use a
monad which combines the state and logging effects.  The *state* effect, as
before, captures computations that can read from and write to some shared value
(or memory).  The *logging* effect captures computations that produce some log,
or trace, as they run.

-------------------------------------------------------------------------------}

{-------------------------------------------------------------------------------

Problem 8-1
-----------

The first task is to write the type class instances for our monadic type.  The
type itself is defined as follows:

-------------------------------------------------------------------------------}

newtype M a = M { run :: Int -> (a, Int, [Int]) }
trace :: M a -> Int -> [Int]
trace m z = ws where
    (_, _, ws) = run m z

{-------------------------------------------------------------------------------

You can read this type as follows: a computation of type `M a` takes an input
(initial state) value of type `Int`, and produces: a result, of type `a`; a
final state, of type `Int`, and a log (or trace), of type `[Int]`.

To let Haskell know that this type is monadic, you have to write two pieces: the
`Functor` instance, which requires an implementation of `fmap`, and the `Monad`
instance, which requires implementations of `return` and `>>=` (the bind
operator).  What should those functions do?

 - `fmap f m`: `f` is an `a -> b` function (that is to say: it's a *pure*
   function, with nothing to say about state or logging).  `m` is a computation
   (that is: it *can* have something to say about state or logging).  The result
   should be a new computation, identical in state and logging to the old
   computation, but applying `f` to the *result* of the computation.

 - `return a` should result in a computation that simply produces the value
   `a`---that is, while it *could* change the state or introduce log messages,
   in this case it *doesn't*.

 - `m >>= k` should *combine* the state and logging effects of `m` and `k`. That
   is: the final state should result from threading the input state through `m`
   and then `k`, and the final log should result from appending the log
   generated by `m` and the log generated by `k`.

If you're stuck in writing any of these functions, try using holes (_) to see
what types you need, and the types of the arguments you have available.

-------------------------------------------------------------------------------}

instance Functor M where
    --fmap :: (a -> b) -> M a -> M b
    fmap f m = M (\a -> case run m a of {(b, c, d) -> (f b, c, d)}) --Replicates function with same state but applies f to the result

instance Monad M where
    -- return :: a -> M a
    --Note: I shortened functions using the reccomendations to get rid of the ugly blue line
    return a = M(a, , []) --Produces Monad value 'a' without changing state
    -- (>>=) :: M a -> (a -> M b) -> M b
    --Note: I shortened functions using the reccomendations to get rid of the ugly blue line
    m >>= k = M helperFunction where --Define helper function to construct operation
      helperFunction i = case run m i of (a, b, c) --ABC defined as initial state values
                                            -> case run (k a) b of (x, y, z) --XYZ defined as new state values
                                                                    -> (x, y, c ++ z) --New state values including operation between 3rd value of old state and new state

{-------------------------------------------------------------------------------

We also need an `Applicative` instance, but we can always generate those the
same way.

-------------------------------------------------------------------------------}

instance Applicative M where
    pure = return
    (<*>) = liftA2 ($)

{-------------------------------------------------------------------------------

Problem 8-2
-----------

The next task is to design the "primitive" operations of the `M` monad---that is
to say, the interface functions that give access to its state and logging
operations.  We have three primitive operations:

 - `get` returns the state value (that is, the stored memory); it doesn't have
   any effect on the log
 - `put` updates the state value; it has no interesting result itself, and
   doesn't have any effecton the log
 - `tell` adds a single value to the log, but doesn't effect the state

-------------------------------------------------------------------------------}    

get :: M Int --gets the monad state value and returns it
get = M(\x -> (x, x, [])) --Returns monad state value x

put :: Int -> M () --Updates the state value
put z = M stateMon where --State of the monad function
          stateMon storedMem = ((), z, []) --Updates the state value in stored memory

tell :: Int -> M () --Adds a single value to the log without affecting the state value
--Note: I shortened functions using the reccomendations to get rid of the ugly blue line
tell w = M((), , [w]) --Adds a value 'w' to the monad

{-------------------------------------------------------------------------------

Problem 8-3
-----------

The final task returns to the Collatz sequences from problem 2, but now from an
imperative perspective.  Just as in problem 2, you need to write two functions:

 - `next` computes the next number in the Collatz sequence: if the current
   number is `n`, the next number is:
     * n `div` 2, if `n` is even
     * 3 * n + 1, if `n` is odd
 - `collatz` will compute the entire Collatz sequence

But, unlike in problem 2, we're not going to represent the current number, or
the sequence, using arguments.  Instead, we'll use the side effects of the `M`
monad:

 - The current value will be stored in the state
 - The sequence will be captured in the log

So:

 - Your `next` function should log the current value, and then update the state
   with the next value in the Collatz sequence
 - Your `collatz` function should invoke `next` until the state reaches 1.

Don't forget to add the final 1 in the sequence to the log!

-------------------------------------------------------------------------------}

next :: M ()
next = do n <- get --Return monad state value n
          tell n --Add n to the monad
          if even n then --If n is even then
            put (div n 2) --update state value at n to n/2
          else --if n is not even then...
            put (3 * n + 1) --times n by 3 then add the final 1 to the log sequence

-- >>> run next 0
-- ((),0,[0,0])

-- >>> run next 1
-- ((),4,[1,1])

-- >>> run next 2
-- ((),1,[2,2])

-- >>> run next 3
-- ((),10,[3])

-- >>> run next 4
-- ((),2,[4])

collatz :: M ()
collatz = do n <- get --Return monad state value n
             if n == 1 then--Base Case for 1
               tell 1 --Add 1 to the monad
             else do next --Move to next number in collatz sequence
                     collatz --Evaluate next value
-- >>> run collatz 2
-- ((),1,[2,2,1])

-- >>> run collatz 1
-- ((),1,[1])

-- >>> run collatz 3
-- ((),1,[3,10,5,16,8,4,2,1])

-- >>> trace collatz 3
-- [3,10,5,16,8,4,2,1]
